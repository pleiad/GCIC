term_parser: ID ARROW RPAREN
##
## Ends in an error in state: 21.
##
## term -> fact ARROW . term [ RPAREN KWD_IN KWD_AS EQUAL EOF DOT ]
##
## The known suffix of the stack is as follows:
## fact ARROW
##

After an `$0` (arrow), a term is expected.
For example:
> $1 $0 Type0

term_parser: ID RPAREN
##
## Ends in an error in state: 56.
##
## term_parser -> term . EOF [ # ]
##
## The known suffix of the stack is as follows:
## term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 20, spurious reduction of production term -> fact
##

I'm currently parsing a term.
After `$0`, the end of file is expected.

term_parser: KWD_FORALL LPAREN ID COLON ID RPAREN COMMA RPAREN
##
## Ends in an error in state: 17.
##
## term -> KWD_FORALL nonempty_list(arg) COMMA . term [ RPAREN KWD_IN KWD_AS EQUAL EOF DOT ]
##
## The known suffix of the stack is as follows:
## KWD_FORALL nonempty_list(arg) COMMA
##

I'm currently parsing a pi type.
After the `,` (comma), the body of the pi type is expected.
For example:
> $2 $1 $0 Type0

term_parser: KWD_FORALL RPAREN
##
## Ends in an error in state: 15.
##
## term -> KWD_FORALL . nonempty_list(arg) COMMA term [ RPAREN KWD_IN KWD_AS EQUAL EOF DOT ]
##
## The known suffix of the stack is as follows:
## KWD_FORALL
##

I'm currently parsing the arguments of a pi type.
After the `$0`, an argument of the form `(id ... id : term)` is expected.
For example:
> $0 (a b : Type0), ...
> $0, ...

term_parser: KWD_LAMBDA LPAREN ID COLON ID KWD_LET
##
## Ends in an error in state: 27.
##
## arg -> LPAREN nonempty_list(id) COLON term . RPAREN [ LPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN nonempty_list(id) COLON term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 20, spurious reduction of production term -> fact
##

I'm currently parsing arguments to a pi type or lambda expression.
After the `$0`, a closing parenthesis is expected `)`.

term_parser: KWD_LAMBDA LPAREN ID COLON ID RPAREN COMMA RPAREN
##
## Ends in an error in state: 32.
##
## term -> KWD_LAMBDA nonempty_list(arg) COMMA . term [ RPAREN KWD_IN KWD_AS EQUAL EOF DOT ]
##
## The known suffix of the stack is as follows:
## KWD_LAMBDA nonempty_list(arg) COMMA
##

I'm parsing the body of lambda expression.
After the `,` (comma), an expression is expected.
For example:
> $2 $1 $0 Type0

term_parser: KWD_LAMBDA LPAREN ID COLON ID RPAREN RPAREN
##
## Ends in an error in state: 25.
##
## nonempty_list(arg) -> arg . [ COMMA ]
## nonempty_list(arg) -> arg . nonempty_list(arg) [ COMMA ]
##
## The known suffix of the stack is as follows:
## arg
##

I'm currently parsing the arguments of a lambda expression.
I expect more arguments of the form `(id ... id : type)` or a `.` (dot) followed
by the body of the lambda.
For example:
> $0, ...
> $0 (id1 id2 : Type0), ...

term_parser: KWD_LAMBDA LPAREN ID COLON RPAREN
##
## Ends in an error in state: 14.
##
## arg -> LPAREN nonempty_list(id) COLON . term RPAREN [ LPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN nonempty_list(id) COLON
##

I'm currently parsing the type of the arguments of a lambda expression.
After the `:` (colon), a term is expected.
For example:
> $2 $1 $0 Type0), ...

term_parser: KWD_LAMBDA LPAREN ID RPAREN
##
## Ends in an error in state: 29.
##
## nonempty_list(id) -> id . [ COLON ]
## nonempty_list(id) -> id . nonempty_list(id) [ COLON ]
##
## The known suffix of the stack is as follows:
## id
##

I'm currently parsing the arguments of a lambda expression.
I expect more identifiers or a colon followed by a type.
For example:
> $0 foo bar : ?0)
> $0 : ?0)

term_parser: KWD_LAMBDA LPAREN RPAREN
##
## Ends in an error in state: 12.
##
## arg -> LPAREN . nonempty_list(id) COLON term RPAREN [ LPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

I'm currently parsing the arguments of a lambda expression.
I expect a nonempty list of identifiers.
For example:
> (x : ?0), ...
> (x y z : ?0), ...
> (x : ?0) (y z : Type1), ...

term_parser: KWD_LAMBDA RPAREN
##
## Ends in an error in state: 11.
##
## term -> KWD_LAMBDA . nonempty_list(arg) COMMA term [ RPAREN KWD_IN KWD_AS EQUAL EOF DOT ]
##
## The known suffix of the stack is as follows:
## KWD_LAMBDA
##

I'm currently parsing the arguments of a lambda expression.
I expect a nonempty list of arguments of the form `(id ... id : type)`.
For example:
> $0 (x : a)
> $0 (x y z : a)

term_parser: KWD_LET ID COLON ID EQUAL ID KWD_IN RPAREN
##
## Ends in an error in state: 37.
##
## term -> KWD_LET id COLON term EQUAL term KWD_IN . term [ RPAREN KWD_IN KWD_AS EQUAL EOF DOT ]
##
## The known suffix of the stack is as follows:
## KWD_LET id COLON term EQUAL term KWD_IN
##

I'm currently parsing the in-term of a let expression.
After the `in`, an expression is expected.

term_parser: KWD_LET ID COLON ID EQUAL ID RPAREN
##
## Ends in an error in state: 36.
##
## term -> KWD_LET id COLON term EQUAL term . KWD_IN term [ RPAREN KWD_IN KWD_AS EQUAL EOF DOT ]
##
## The known suffix of the stack is as follows:
## KWD_LET id COLON term EQUAL term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 20, spurious reduction of production term -> fact
##

I'm currently parsing the bounded term of a let expression.
After the `=`, an expression is expected followed by `in`.
For example:
> $5 $4 $3 ... $1 $0 in ...

term_parser: KWD_LET ID COLON ID EQUAL RPAREN
##
## Ends in an error in state: 35.
##
## term -> KWD_LET id COLON term EQUAL . term KWD_IN term [ RPAREN KWD_IN KWD_AS EQUAL EOF DOT ]
##
## The known suffix of the stack is as follows:
## KWD_LET id COLON term EQUAL
##

I'm currently parsing the bounded term of a let expression.
After the `=`, an expression is expected followed by `in`.
For example:
> $4 $3 $2 ... $0 in ...

term_parser: KWD_LET ID COLON ID RPAREN
##
## Ends in an error in state: 34.
##
## term -> KWD_LET id COLON term . EQUAL term KWD_IN term [ RPAREN KWD_IN KWD_AS EQUAL EOF DOT ]
##
## The known suffix of the stack is as follows:
## KWD_LET id COLON term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 20, spurious reduction of production term -> fact
##

I'm currently parsing the bounded term's type of a let expression.
After the `:`, an expression is expected followed by `=`.
For example:
> $3 $2 $1 $0 = ...
> $3 $2 $1 $0 x = ...

term_parser: KWD_LET ID COLON RPAREN
##
## Ends in an error in state: 10.
##
## term -> KWD_LET id COLON . term EQUAL term KWD_IN term [ RPAREN KWD_IN KWD_AS EQUAL EOF DOT ]
##
## The known suffix of the stack is as follows:
## KWD_LET id COLON
##

I'm currently parsing the binder's type of a let expression.
After the `:`, an expression is expected followed by `=`.
For example:
> $2 $1 $0 ?0 = ...
> $2 $1 $0 foo Type0 ?1 = ...

term_parser: KWD_LET ID RPAREN
##
## Ends in an error in state: 9.
##
## term -> KWD_LET id . COLON term EQUAL term KWD_IN term [ RPAREN KWD_IN KWD_AS EQUAL EOF DOT ]
##
## The known suffix of the stack is as follows:
## KWD_LET id
##

I'm currently parsing a let expression.
After the identifier, a `:` (colon) is expected followed by a type.
For example:
> $1 $0 : ?0 = ...
> $1 $0 : foo Type0 ?1 = ...

term_parser: KWD_LET RPAREN
##
## Ends in an error in state: 7.
##
## term -> KWD_LET . id COLON term EQUAL term KWD_IN term [ RPAREN KWD_IN KWD_AS EQUAL EOF DOT ]
##
## The known suffix of the stack is as follows:
## KWD_LET
##

I'm currently parsing the binder of a let expression.
After the `let`, an identifier is expected followed by `:`.
For example:
> $0 x : ?0 = ...
> $0 f : foo Type0 ?1 = ...

term_parser: KWD_UNIVERSE RPAREN
##
## Ends in an error in state: 5.
##
## atom -> KWD_UNIVERSE . INT [ RPAREN LPAREN KWD_UNKNOWN KWD_UNIVERSE KWD_IN KWD_AS ID EQUAL EOF DOT ARROW ]
##
## The known suffix of the stack is as follows:
## KWD_UNIVERSE
##

I'm currently parsing the level of a universe.
After the `$0`, a non-negative integer is expected.
For example:
> $0 0
> Type1
> â–¡1

term_parser: KWD_UNKNOWN RPAREN
##
## Ends in an error in state: 3.
##
## atom -> KWD_UNKNOWN . INT [ RPAREN LPAREN KWD_UNKNOWN KWD_UNIVERSE KWD_IN KWD_AS ID EQUAL EOF DOT ARROW ]
##
## The known suffix of the stack is as follows:
## KWD_UNKNOWN
##

I'm currently parsing the universe level of an unknown term.
After the `$0`, a non-negative integer is expected.
For example:
> $0 0
> ?1

term_parser: LPAREN ID KWD_LET
##
## Ends in an error in state: 39.
##
## atom -> LPAREN term . RPAREN [ RPAREN LPAREN KWD_UNKNOWN KWD_UNIVERSE KWD_IN KWD_AS ID EQUAL EOF DOT ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 20, spurious reduction of production term -> fact
##

I'm currently parsing a parenthesised term.
After the `(` a term is expected followed by a closing parenthesis `)`.
For example:
> (f x y)
> (foo ?0 y)
> (fun (x : Type0). x)

term_parser: LPAREN RPAREN
##
## Ends in an error in state: 2.
##
## atom -> LPAREN . term RPAREN [ RPAREN LPAREN KWD_UNKNOWN KWD_UNIVERSE KWD_IN KWD_AS ID EQUAL EOF DOT ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

I'm currently parsing a parenthesised term.
After the `(` a term is expected followed by a closing parenthesis `)`.
For example:
> (f x y)
> (foo ?0 y)
> (fun (x : Type0). x)

term_parser: RPAREN
##
## Ends in an error in state: 54.
##
## term_parser' -> . term_parser [ # ]
##
## The known suffix of the stack is as follows:
##
##

I'm currently parsing a term.
At the top level, a term is expected.
For example:
> let f : ?0 = Type0 in f
> fun (x : Type0). x

program_parser: KWD_CHECK ID KWD_AS ID RPAREN
##
## Ends in an error in state: 49.
##
## command -> KWD_CHECK term KWD_AS term . DOT [ EOF ]
##
## The known suffix of the stack is as follows:
## KWD_CHECK term KWD_AS term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 20, spurious reduction of production term -> fact
##

I'm currently parsing a `Check` command.
At the end of the command, a `.` (dot) is expected.

program_parser: KWD_CHECK ID KWD_AS RPAREN
##
## Ends in an error in state: 48.
##
## command -> KWD_CHECK term KWD_AS . term DOT [ EOF ]
##
## The known suffix of the stack is as follows:
## KWD_CHECK term KWD_AS
##

I'm currently parsing a `Check` command.
After the `As`, a term followed by `.` (dot) is expected.
For example:
> $2 $1 $0 ?0.

program_parser: KWD_CHECK ID RPAREN
##
## Ends in an error in state: 47.
##
## command -> KWD_CHECK term . KWD_AS term DOT [ EOF ]
##
## The known suffix of the stack is as follows:
## KWD_CHECK term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 20, spurious reduction of production term -> fact
##

I'm currently parsing a `Check` command.
After the term to be checked, the keyword `As` followed by a type nad a `.` (dot) is expected.
For example:
> $1 $0 As ?0.

program_parser: KWD_CHECK RPAREN
##
## Ends in an error in state: 46.
##
## command -> KWD_CHECK . term KWD_AS term DOT [ EOF ]
##
## The known suffix of the stack is as follows:
## KWD_CHECK
##

I'm currently parsing a `Check` command.
After the `$0` keyword, an expression is expected.
For example:
> $0 Type0 As ?0.

program_parser: KWD_ELABORATE ID RPAREN
##
## Ends in an error in state: 44.
##
## command -> KWD_ELABORATE term . DOT [ EOF ]
##
## The known suffix of the stack is as follows:
## KWD_ELABORATE term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 20, spurious reduction of production term -> fact
##

I'm currently parsing an `Elaborate` command.
At the end of the command, a `.` (dot) is expected.

program_parser: KWD_ELABORATE RPAREN
##
## Ends in an error in state: 43.
##
## command -> KWD_ELABORATE . term DOT [ EOF ]
##
## The known suffix of the stack is as follows:
## KWD_ELABORATE
##

I'm currently parsing an `Elaborate` command.
After the `$0` keyword, an expression is expected.
For example:
> $0 (fun (x : ?0), x).

program_parser: KWD_EVAL ID DOT RPAREN
##
## Ends in an error in state: 52.
##
## program_parser -> command . EOF [ # ]
##
## The known suffix of the stack is as follows:
## command
##

After a `.` (dot) the end of file is expected.

program_parser: KWD_EVAL ID RPAREN
##
## Ends in an error in state: 41.
##
## command -> KWD_EVAL term . DOT [ EOF ]
##
## The known suffix of the stack is as follows:
## KWD_EVAL term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 20, spurious reduction of production term -> fact
##

I'm parsing an Eval command.
After the term, a `.` (dot) is expected.

program_parser: KWD_EVAL RPAREN
##
## Ends in an error in state: 1.
##
## command -> KWD_EVAL . term DOT [ EOF ]
##
## The known suffix of the stack is as follows:
## KWD_EVAL
##

I'm currently parsing an `Eval` command.
After the `$0` keyword, an expression is expected.
For example:
> $0 (fun (x : ?0), x).

program_parser: RPAREN
##
## Ends in an error in state: 0.
##
## program_parser' -> . program_parser [ # ]
##
## The known suffix of the stack is as follows:
##
##

I'm currently parsing a program.
At the top level, a command is expected.
For example:
> Eval let f : ?0 = Type0 in f.
> Check (fun (x : Type0). x) As ?0 -> ?0.

